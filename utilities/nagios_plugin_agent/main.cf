bundle agent meta_nagios_plugin_agent{
vars:
    "optional_argument[handle][plugin_name]"                  string => "";
    "optional_argument[handle][args]"                         string => "";
    "optional_argument[handle][_plugin_path]"                 string => "";
    "optional_argument[handle][_if_elapsed]"                  string => "";
    "optional_argument[handle][_execution_context]"           string => "";
    "optional_argument[handle][_usebundle_if_ok]"             string => "";
    "optional_argument[handle][_usebundle_if_warning]"        string => "";
    "optional_argument[handle][_usebundle_if_critical]"       string => "";
    "optional_argument[handle][_usebundle_if_unknown]"        string => "";
    "optional_argument[handle][_usebundle_if_protocol_error]" string => "";
}

bundle agent nagios_plugin_agent(params){
# expects array
# TODO: need to add a handle to this so that you can execute a plugin with the same name multiple times 
#       think chech_http and multiple websites
#
#       probably need to make the handle the first key in the array, possibly add a _plugin_name override if the handle is not the same as the plugin name (multiple http checks)
#
#   "check[check_handle][args]" string => "plugin arguments here";
#   "check[check_handle][_plugin_path]" 
#       string  => "/usr/lib64/nagios/plugins/",
#       comment => "override the directory that the plugin is installed in
#                   this defaults to the typical location based on your arch/distro";
#   "check[plugin_name][_execution_context] string => "class expression of when to execute";
#       comment => "This is a class restriction expression used to restrict plugin execution for defined plugin"

    vars:
        # This is where we expect to find the nagios plugin wrapper script
        # We should default this to site.nagios_plugin_wraper or g.nagios_plugin_wrapper or global.nagios_plugin_wrapper
        "nagios_plugin_wrapper" string => "$(sys.workdir)/inputs/sketches/nagios-plugin-agent/modules/nagios_plugin_wrapper";

        "check_handle_index"    slist  => getindices("$(params)");
        # we should default nagios_plugin_path to the place you expect for both x86 or x86_64
    
    # Set default values
        any::
            "mycheck[$(check_handle_index)][plugin_name]"
                string => "$(check_handle_index)",
                policy => "overridable";

            "mycheck[$(check_handle_index)][args]"
                string => "",
                policy => "overridable";

            "mycheck[$(check_handle_index)][_if_elapsed]" 
                string => "60",
                policy => "overridable";

            "mycheck[$(check_handle_index)][_execution_context]" 
                string => "any",
                policy => "overridable";

        ubuntu.x86_64::
            "mycheck[$(check_handle_index)][_plugin_path]"
                string => "/usr/lib/nagios/plugins/",
                policy => "overridable";

        x86::
            "mycheck[$(check_handle_index)][_plugin_path]"
                string => "",
                policy => "overridable";

    # Copy configuration paramaters passed into local array
        any::
            "mycheck[$(check_handle_index)][plugin_name]"
                string     => "$($(params)[$(check_handle_index)][plugin_name])",
                policy     => "overridable",
                ifvarclass => "$(check_handle_index)_plugin_name_defined";

            "mycheck[$(check_handle_index)][args]"
                string     => "$($(params)[$(check_handle_index)][args])",
                policy     => "overridable",
                ifvarclass => "$(check_handle_index)_args_defined";

            "mycheck[$(check_handle_index)][_if_elapsed]"
                string     => "$($(params)[$(check_handle_index)][_if_elapsed])",
                policy     => "overridable",
                ifvarclass => "$(check_handle_index)__if_elapsed_defined";

             "mycheck[$(check_handle_index)][_execution_context]"
                string     => "$($(params)[$(check_handle_index)][_execution_context])",
                policy     => "overridable",
                ifvarclass => "$(check_handle_index)__execution_context_defined";

            "mycheck[$(check_handle_index)][_plugin_path]"
                string     => "$($(params)[$(check_handle_index)][_plugin_path])",
                policy     => "overridable",
                ifvarclass => "$(check_handle_index)__plugin_path_defined";

            "mycheck[$(check_handle_index)][_usebundle_if_ok]"
                string     => "$($(params)[$(check_handle_index)][_usebundle_if_ok])",
                policy     => "overridable",
                ifvarclass => "$(check_handle_index)__usebundle_if_ok_defined";

            "mycheck[$(check_handle_index)][_usebundle_if_warning]"
                string     => "$($(params)[$(check_handle_index)][_usebundle_if_warning])",
                policy     => "overridable",
                ifvarclass => "$(check_handle_index)__usebundle_if_warning_defined";

            "mycheck[$(check_handle_index)][_usebundle_if_critical]"
                string     => "$($(params)[$(check_handle_index)][_usebundle_if_critical])",
                policy     => "overridable",
                ifvarclass => "$(check_handle_index)__usebundle_if_critical_defined";

            "mycheck[$(check_handle_index)][_usebundle_if_unknown]"
                string     => "$($(params)[$(check_handle_index)][_usebundle_if_unknown])",
                policy     => "overridable",
                ifvarclass => "$(check_handle_index)__usebundle_if_unknown_defined";

            "mycheck[$(check_handle_index)][_usebundle_if_protocol_error]"
                string     => "$($(params)[$(check_handle_index)][_usebundle_if_protocol_error])",
                policy     => "overridable",
                ifvarclass => "$(check_handle_index)__usebundle_if_protocol_error_defined";


    classes:
        # Define a generic alert class if check was not OK
        # move this to the handle name
        "nagios_alert" or => {
                               "nagios_plugin_$(check_handle_index)_warning",
                               "nagios_plugin_$(check_handle_index)_critical",
                               "nagios_plugin_$(check_handle_index)_unknown",
                               "nagios_plugin_$(check_handle_index)_protocol_error",
                              };

        # Prefert to set a class here, instead of with files to reduce globally set classes unnecisarily
        "nagios_plugin_wrapper_exists"  expression => fileexists("$(nagios_plugin_wrapper)");

        # Define classes if paramaters are defined so that we can copy them over the local defaults
        "$(check_handle_index)_plugin_name_defined" 
            expression => isvariable("$(params)[$(check_handle_index)][plugin_name]");

        "$(check_handle_index)_args_defined" 
            expression => isvariable("$(params)[$(check_handle_index)][args]");

        "$(check_handle_index)__plugin_path_defined" 
            expression => isvariable("$(params)[$(check_handle_index)][_plugin_path]");

        "$(check_handle_index)__execution_context_defined" 
            expression => isvariable("$(params)[$(check_handle_index)][_execution_context]");

        "$(check_handle_index)__usebundle_if_ok_defined" 
            expression => isvariable("$(params)[$(check_handle_index)][_usebundle_if_ok]");

        "$(check_handle_index)__usebundle_if_warning_defined" 
            expression => isvariable("$(params)[$(check_handle_index)][_usebundle_if_warning]");

        "$(check_handle_index)__usebundle_if_critical_defined" 
            expression => isvariable("$(params)[$(check_handle_index)][_usebundle_if_critical]");

        "$(check_handle_index)__usebundle_if_unknown_defined" 
            expression => isvariable("$(params)[$(check_handle_index)][_usebundle_if_unknown]");

        "$(check_handle_index)__usebundle_if_protocol_error_defined" 
            expression => isvariable("$(params)[$(check_handle_index)][_usebundle_if_protocol_error]");


        # Defauts don't get overridden until the second pass, this allows us to check for that
        # We dont want to execute the commands until after all paramaters have been copied over the defaults
        "paramaters_copied" or => { "done_checking_paramaters_defined" };
        "done_checking_paramaters_defined" expression => isvariable("check_handle_index");

    files:
        # the file is part of the sketch, it might be copied in place by normal policy update,
        # but if not we set the source to a sane default.
          # set default to $(sys.policy_hub), path masterfiles/sketches/sketchname/cf3-nagios-plugin-wrapper/modules/nagios_plugin_wrapper
          # overrie with "hidden" variables _source_servers (list), _source_path ?
        "$(sys.workdir)/sketches/nagios-plugin-agent/modules/nagios_plugin_wrapper"
            perms     => mog("755","root","root"),
            action    => if_elapsed("60"),
            # I am thinking depending on a remote copy is both expensive and brittle, perhaps its best to inline the script, its not long
            copy_from => remote_cp("$(sys.work)/sketches/nagios-plugin-agent/modules/nagios_plugin_wrapper", "$(sys.policy_hub)");

    commands:
        paramaters_copied::
        #paramaters_copied.nagios_plugin_wrapper_exists::
        # This is kind of hard to read, its "plugin_wrapper handle path/plugin args"
            "$(nagios_plugin_wrapper) $(check_handle_index) $(mycheck[$(check_handle_index)][_plugin_path])/$(mycheck[$(check_handle_index)][plugin_name]) $(mycheck[$(check_handle_index)][args])"
                module     => "true",
                action     => if_elapsed("$(mycheck[$(check_handle_index)][_if_elapsed])"),
                handle     => "nagios_plugin_agent_commands_nagios_plugin_wrapper_check_handle_index",
                depends_on => { "nagios_plugin_agent_files_nagios_plugin_wrapper" },
                ifvarclass => "$(mycheck[$(check_handle_index)][_execution_context])";

        nagios_plugin_wrapper_exists::
            "/bin/echo $(nagios_plugin_wrapper) $(nagios_plugin_path) $(nagios_plugin_name) $(nagios_plugin_args)"
                module => "true";
                #no_output => "true";
    
    methods:
        # Here we call bundles if requested on specific check status
        "ok" usebundle => "$(mycheck[$(check_handle_index)][_usebundle_if_ok])",
            ifvarclass => "$(check_handle_index)__usebundle_if_ok_defined";

        "warning" usebundle => "$(mycheck[$(check_handle_index)][_usebundle_if_warning])",
            ifvarclass => "$(check_handle_index)__usebundle_if_warning_defined";

        "critical" usebundle => "$(mycheck[$(check_handle_index)][_usebundle_if_critical])",
            ifvarclass => "$(check_handle_index)__usebundle_if_critical_defined";

        "unknown" usebundle => "$(mycheck[$(check_handle_index)][_usebundle_if_unknown])",
            ifvarclass => "$(check_handle_index)__usebundle_if_unknown_defined";

        "protocol_error" usebundle => "$(mycheck[$(check_handle_index)][_usebundle_if_protocol_error])",
            ifvarclass => "$(check_handle_index)__usebundle_if_protocol_error_defined";

   reports:
        nagios_alert::
            "Nagios plugin $(check_handle_index) with $(mycheck[$(check_handle_index)][plugin_name]) on $(sys.host) reports '$(nagios_plugin_wrapper.$(check_handle_index)_output)' on $(sys.date)";


        verbose_mode|debug::
            "plugin_name:       $(mycheck[$(check_handle_index)][plugin_name])";
            "plugin_path:       $(mycheck[$(check_handle_index)][_plugin_path])";
            "args:              $(mycheck[$(check_handle_index)][args])";
            "if_elapsed:        $(mycheck[$(check_handle_index)][_if_elapsed])";
            "execution_context: $(mycheck[$(check_handle_index)][_execution_context])";
}
