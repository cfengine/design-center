bundle agent local_user_management_add_users_fileedit (users) {
# Expects to be passed a two-dimensional array keyed on username and field
# The following fields are required.
# gecos, uid, gid, home, shell, passwdhash
# Dependancies: replace_or_add from copbl svn 105 or greater, perl
# Example Usage:
#   vars:
#       "users[testuser][gecos]"          string => "My Test User";
#       "users[testuser][uid]"            string => "1500";
#       "users[testuser][gid]"            string => "1500";
#       "users[testuser][home]"           string => "/home/testuser";
#       "users[testuser][shell]"          string => "/bin/bash";
#       "users[testuser][passwdhash]"     string => "$1$cCMJbSmS$/tQtxSsLZmYq3/zp1Vm/l0";
#       # Optional settings
#       "users[testuser][groupname]       string => "mygroupname";
#       "users[testuser][_gid_non_unique] string => "anythinggoeshere";
#       If groupname is set a named group will be created with the specified gid
#       by default we wont create a named group with a non_unique gid, setting _gid_non_unique
#       enables this behavior.
# Note:
# This bundle does not handle creating groups, if you assign a gid of a non-existant group
# you should still be able to log in, there is just no named group associated with the gid,
# if you want a named group you should promise that seperately.


    vars:
        linux::
            "skel"                      string => "/etc/skel/";
            "pwfile"                    string => "/etc/passwd";
            "shadowfile"                string => "/etc/shadow";
            "groupfile"                 string => "/etc/group";
            "userlist"                  slist  => getindices("$(users)");
            "pwentry[$(userlist)]"      string => "$(userlist):x:$($(users)[$(userlist)][uid]):$($(users)[$(userlist)][gid]):$($(users)[$(userlist)][gecos]):$($(users)[$(userlist)][home]):$($(users)[$(userlist)][shell])";
            "groupentry[$(userlist)]"   string => "$($(users)[$(userlist)][groupname]):x:$($(users)[$(userlist)][gid]):";

            "days_since_epoch"
                string => execresult("/usr/bin/perl -le 'print int time/(60*60*24)'", "noshell"),
                ifvarclass => "local_user_management_add_users_fileedit_add_$(userlist)",
                comment     => "Only calculate if we need to add a user, otherwise its just wasteful";

            "shadowentry[$(userlist)]"
                string => "$(userlist):$($(users)[$(userlist)][passwdhash]):$(days_since_epoch):0:99999:7:::",
                ifvarclass => "local_user_management_add_users_fileedit_add_$(userlist)",
                comment    => "Only construct the shadow entry for a user if we need to add the user";

    classes:
    # Check if different variables are defined
        "gecos_defined_$(userlist)"
            expression => isvariable("$(users)[$(userlist)][gecos]"),
            comment    => "I consider gecos a required field, check if its defined";

        "uid_defined_$(userlist)"
            expression => isvariable("$(users)[$(userlist)][uid]"),
            comment    => "Since I don't yet do automatic next uid selection
                           uid is a required field, check if its defined";

        "gid_defined_$(userlist)"
            expression => isvariable("$(users)[$(userlist)][gid]"),
            comment    => "Since I dont yet do automatic next gid selection
                           gid is a required field, check if its defined";

        "shell_defined_$(userlist)"
            expression => isvariable("$(users)[$(userlist)][shell]"),
            comment    => "I really think its a good idea to set the shell
                           to something, check if its defined";

        "home_defined_$(userlist)"
            expression => isvariable("$(users)[$(userlist)][home]"),
            comment => "Users really should have a home directoy defined,
                        check if it is defined";

        "passwdhash_defined_$(userlist)"
            expression => isvariable("$(users)[$(userlist)][passwdhash]"),
            comment    => "Without a password set the user wont be able to log in,
                           this is easily debateable to not be a required field";

        "groupname_defined_$(userlist)"
            expression => isvariable("$(users)[$(userlist)][groupname]"),
            comment    => "This is optional, if the groupname is defined
                           we will create a named group with the defined gid.
                           Non-unique gid is allowed with the use of the
                           _gid_non_unique_defined flag";

        "allow_non_unique_gid_$(userlist)"
            expression => isvariable("$(users)[$(userlist)][_gid_non_unique]"),
            comment    => "This is optional, the value does not matter
                           if its defined at all we allow the creation of
                           a named group with a duplicate uid";

        "required_elements_defined_$(userlist)"
            and => { "gecos_defined_$(userlist)",
                   },
            comment => "These are required to create a user";

        required_elements_defined::
            "local_user_management_add_users_fileedit_add_$(userlist)"
                not     => userexists("$(userlist)"),
                comment => "Trigger a class so we know we need to create the user if it does not exist";

        # I need to think on this more, if we blindly insert of groupname does not exist it can
        # lead to multiple groupnames with the same gid
        #groupname_defined::
        any::
            "local_user_management_add_users_fileedit_add_$($(users)[$(userlist)][groupname])",
                not     => groupexists("$($(users)[$(userlist)][groupname])"),
                ifvarclass => "groupname_defined_$(userlist)",
                comment => "Trigger a class so we know we should see about creating a user";

            # we only need to know if the gid is in use if the optional named group was defined
            # Also we only really need to know if the gid is in use if we care about not creating
            # multiple named groups with the same gid.
            "gid_in_use_$(userlist)_$($(users)[$(userlist)][gid])"
                expression => regline(".*\:.*\:$($(users)[$(userlist)][gid])\:.*$", "/etc/group"),
                #ifvarclass => "allow_non_unique_gid_$(userlist)|groupname_defined_$(userlist)",
                ifvarclass => "groupname_defined_$(userlist)",
                comment => "If we are going to add a named group, we should see if the gid
                            is already in use";

            "gid_not_in_use_$(userlist)_$($(users)[$(userlist)][gid])"
                not => "gid_in_use_$(userlist)_$($(users)[$(userlist)][gid])";


            "create_group_and_allow_non_unique_$(userlist)"
                and     => {"groupname_defined_$(userlist)", "allow_non_unique_gid_$(userlist)"},
                comment => "Crete a class when we would like to create a user,
                            and when we dont care about having unique gids";

            "create_group_and_not_conflicting_gid_$(userlist)"
                and => {"groupname_defined_$(userlist)", "!gid_in_use_$(userlist)_$($(users)[$(userlist)][gid])"};

            "attempt_group_creation_$(userlist)"
                or => {"create_group_and_allow_non_unique_$(userlist)", "create_group_and_not_conflicting_gid_$(userlist)"};

    files:
        linux::
            "$(pwfile)"
                edit_line  => replace_or_add("$(userlist):.*", "$(pwentry[$(userlist)])"),
                ifvarclass => "local_user_management_add_users_fileedit_add_$(userlist)",
                comment   => "Ensure user exists";

            "$(shadowfile)"
                edit_line  => replace_or_add("$(userlist):.*", "$(shadowentry[$(userlist)])"),
                ifvarclass => "local_user_management_add_users_fileedit_add_$(userlist)",
                comment    => "Ensure user has password entry";

            "$($(users)[$(userlist)][home])/."
                create      => "true",
                perms       => mog("755", "$($(users)[$(userlist)][uid])", "$($(users)[$(userlist)][gid])"),
                classes     => if_repaired("local_user_management_add_users_fileedit_seed_$(userlist)"),
                ifvarclass => "local_user_management_add_users_fileedit_add_$(userlist)",
                comment     => "Make sure users home directory exists";

            "$($(users)[$(userlist)][home])/."
                depth_search    => recurse("inf"),
                copy_from       => seed_cp("$(local_user_management_add_users_fileedit.skel)"),
                perms           => og("$($(users)[$(userlist)][uid])", "$($(users)[$(userlist)][gid])"),
                ifvarclass      => "local_user_management_add_users_fileedit_seed_$(userlist)",
                comment         => "Seed home directory with skell, but only when we create the home
                                    directory the user should have the choice to remove the seeded files";

        # if groupname defined and allow non unique or
        # if groupname defined and there is no gid conflict
        #linux.((groupname_defined.allow_non_unique_gid)|groupname_defined.!gid_in_use)::
            "/etc/group"
                create    => "true",
                edit_line => append_if_no_line("$(groupentry[$(userlist)])"),
                ifvarclass => "attempt_group_creation_$(userlist)";

    reports:
    cfengine::

    "groupname_defined",
        ifvarclass => "groupname_defined_$(userlist)";

    "allow_non_unique_gid",
        ifvarclass => "allow_non_unique_gid_$(userlist)";

    "gid in use",
        ifvarclass => "gid_in_use_$(userlist)_$($(users)[$(userlist)][gid])";

    "gid not in use",
        ifvarclass => "gid_not_in_use_$(userlist)_$($(users)[$(userlist)][gid])";

    "create group and allow non unique for $(userlist)",
        ifvarclass => "create_group_and_allow_non_unique_$(userlist)";

#    "gecos OK",
#        ifvarclass => "gecos_defined_$(userlist)";
#    "uid OK",
#        ifvarclass => "uid_defined_$(userlist)";
#    "gid OK",
#        ifvarclass => "gid_defined_$(userlist)";
#    "home OK",
#        ifvarclass => "home_defined_$(userlist)";
#    "shell OK",
#        ifvarclass => "shell_defined_$(userlist)";
#    "passwdhash OK",
#        ifvarclass => "passwdhash_defined_$(userlist)";
#
#    "groupname defined",
#        ifvarclass => "groupname_defined_$(userlist)";
#
#    "gid IN USE",
#        ifvarclass => "gid_in_use_$(userlist)_$(gid)";
#
#    "Non unique allowed and groupname defined",
#        ifvarclass => "allow_non_unique_gid_$(userlist).groupname_defined_$(userlist)";
#
#    "ALL REQUIRED ELEMENTS DEFINED FOR $(userlist)",
#        ifvarclass => "required_elements_defined_$(userlist)";


#        gecos_defined::
#            "gecos is defined";
#        groupname_defined::
#            "groupname_defined";
}
