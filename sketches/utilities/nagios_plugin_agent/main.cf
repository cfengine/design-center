bundle agent nagios_plugin_agent(prefix)
{
  # TODO: get defaults from meta bundle, I think this will necisitate forcing commands to not run on first pass
  # TODO: get module from policyhub, determine best way to do this
  # 
  # expects prefix (variable prefix namespace from calling bundle), this is cfsketch-style
  # in this example "check_dummy_OK" is the prefix, any variable prefixed with that would be 
  # in scope for that call of this bundle
  # vars:
  #     "check_dummy_OK_plugin_name" string => "check_dummy";
  #     "check_dummy_OK_args" string => "0 Test ok";
  #     "check_dummy_OK_usebundle_if_ok" string => "handler_ok";
  #     "check_dummy_OK_bundle_home" string => "/home/cmdln/src/github/nickanderson/design-center/utilities/nagios_plugin_agent";
  #     "check_dummy_OK_plugin_path" string => "/usr/lib/nagios/plugins/";
  #     "check_dummy_OK_execution_context" string => "any";
  # methods:
  #     "any" usebundle => nagios_plugin_agent("main.check_dummy_OK_");


  vars:
      "canon_prefix" string => canonify("$(prefix)");
      "nagios_plugin_wrapper" string => "$($(prefix)bundle_home)/modules/nagios_plugin_wrapper";

  classes:
      # Define a generic alert class if check was not OK
      # move this to the handle name
      "nagios_alert" or => {
                             "nagios_plugin_$(canon_prefix)_warning",
                             "nagios_plugin_$(canon_prefix)_critical",
                             "nagios_plugin_$(canon_prefix)_unknown",
                             "nagios_plugin_$(canon_prefix)_protocol_error",
                           };

      # Prefer to set a class here, instead of with files to reduce globally set classes unnecisarily
      "$(canon_prefix)nagios_plugin_wrapper_exists"  expression => fileexists("$(nagios_plugin_wrapper)");

      #    files:
      #        # the file is part of the sketch, it might be copied in place by normal policy update,
      #        # but if not we set the source to a sane default.
      #          # set default to $(sys.policy_hub), path masterfiles/sketches/sketchname/cf3-nagios-plugin-wrapper/modules/nagios_plugin_wrapper
      #          # overrie with "hidden" variables _source_servers (list), _source_path ?
      #        "$(sys.workdir)/inputs/sketches/nagios-plugin-agent/modules/nagios_plugin_wrapper"
      #            perms     => mog("755","root","root"),
      #            action    => if_elapsed("60"),
      #            # I am thinking depending on a remote copy is both expensive and brittle, perhaps its best to inline the script, its not long
      #            copy_from => remote_cp("$(sys.workdir)/inputs/sketches/nagios-plugin-agent/modules/nagios_plugin_wrapper", "$(sys.policy_hub)");

    "$(canon_prefix)usebundle_if_ok_defined"
        expression => isvariable("$(prefix)usebundle_if_ok");
    "$(canon_prefix)usebundle_if_warning_defined"
        expression => isvariable("$(prefix)usebundle_if_warning");
    "$(canon_prefix)usebundle_if_critical_defined"
        expression => isvariable("$(prefix)usebundle_if_critical");
    "$(canon_prefix)usebundle_if_unknown_defined"
        expression => isvariable("$(prefix)usebundle_if_unknown");
    "$(canon_prefix)usebundle_if_protocol_error_defined"
        expression => isvariable("$(prefix)usebundle_if_protocol_error");
    "$(canon_prefix)usebundle_not_ok_defined"
        expression => isvariable("$(prefix)usebundle_not_ok");

    "$(canon_prefix)has_output"
        expression => isvariable("nagios_plugin_wrapper.$(canon_prefix)_output");

  commands:
      # This is kind of hard to read, its "plugin_wrapper handle path/plugin args"
      "$(nagios_plugin_wrapper)"
      args        => "$(canon_prefix) $($(prefix)plugin_path)/$($(prefix)plugin_name) $($(prefix)args)",
      module     => "true",
      action     => if_elapsed("$($(prefix)if_elapsed)"),
      handle     => "nagios_plugin_agent_commands_nagios_plugin_wrapper_$(canon_prefix)",
      depends_on => { "nagios_plugin_agent_files_nagios_plugin_wrapper" }, # ???
      ifvarclass => "$($(prefix)execution_context)";

  methods:
      # Here we call bundles if requested on specific check status
      "ok" usebundle => "$($(prefix)usebundle_if_ok)",
      ifvarclass => "$(canon_prefix)usebundle_if_ok_defined.nagios_plugin_$(canon_prefix)_ok";

      "warning" usebundle => "$($(prefix)usebundle_if_warning)",
      ifvarclass => "$(canon_prefix)usebundle_if_warning_defined.nagios_plugin_$(canon_prefix)_warning";

      "critical" usebundle => "$($(prefix)usebundle_if_critical)",
      ifvarclass => "$(canon_prefix)usebundle_if_critical_defined.nagios_plugin_$(canon_prefix)_critical";

      "unknown" usebundle => "$($(prefix)usebundle_if_unknown)",
      ifvarclass => "$(canon_prefix)usebundle_if_unknown_defined.nagios_plugin_$(canon_prefix)_unknown";

      "protocol_error" usebundle => "$($(prefix)usebundle_if_protocol_error)",
      ifvarclass => "$(canon_prefix)usebundle_if_protocol_error_defined.nagios_plugin_$(canon_prefix)_protocol_error";

      "not_ok" usebundle => "$($(prefix)usebundle_not_ok)",
      ifvarclass => "$(canon_prefix)usebundle_not_ok_defined.nagios_alert";

  reports:
    nagios_alert::
      "Nagios plugin $($(prefix)plugin_name) with on $(sys.host) reports '$(nagios_plugin_wrapper.$(canon_prefix)_output)' on $(sys.date)",
      ifvarclass => "$(canon_prefix)has_output";

    verbose_mode|debug::
      "plugin_name:       $($(prefix)plugin_name)";
      "plugin_path:       $($(prefix)plugin_path)";
      "args:              $($(prefix)args)";
      "if_elapsed:        $($(prefix)if_elapsed)";
      "execution_context: $($(prefix)execution_context)";
}

bundle agent meta_nagios_plugin_agent
{
  vars:
      "argument[plugin_name]" string => "string";
      "argument[args]"        string => "string";

      # Optionally call bundles on specific status
      "optional_argument[usebundle_if_ok]"             string => "string";
      "optional_argument[usebundle_if_warning]"        string => "string";
      "optional_argument[usebundle_if_critical]"       string => "string";
      "optional_argument[usebundle_if_unknown]"        string => "string";
      "optional_argument[usebundle_if_protocol_error]" string => "string";
      # not_ok encompases warning, critical, unknown, and protocol_error status
      # This is probably the most common use case
      "optional_argument[usebundle_not_ok]"            string => "string";

      # this can't be determined from within the bundle due to:
      # https://cfengine.com/bugtracker/view.php?id=718
      "optional_argument[bundle_home]" string => "string";
      # this default will probably be incorrect, either use cf-sketch.pl --generate
      # or supply it yourself
      "default[bundle_home]"           string => dirname("$(this.promise_filename)");

      # you almost definitely want to override this for x64 vs x86
      "optional_argument[plugin_path]" string => "string";
      "default[plugin_path]"           string => "/usr/lib64/nagios/plugins";

      "optional_argument[execution_context]" string => "string";
      "default[execution_context]" string => "any";

      "optional_argument[if_elapsed]" string => "string";
      "default[if_elapsed]" string => "60";
}
