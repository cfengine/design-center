body file control
{
      namespace => "cfdc_redis";
}

bundle agent server(runenv, metadata, pidfile, port, address, timeout, dbfilename, datadir, logfile, glueoutputbuf, shareobjectspoolsize, masterserver, masterport, saves)
{
  classes:
      "$(vars)" expression => "default:runenv_$(runenv)_$(vars)";
      "not_$(vars)" expression => "!default:runenv_$(runenv)_$(vars)";

  vars:
      "vars" slist => { "@(default:$(runenv).env_vars)" };
      "$(vars)" string => "$(default:$(runenv).$(vars))";

  methods:
      "utils" usebundle => default:eu($(runenv));

      "REDIS INSTALL $(runenv)"
      usebundle => install,
      inherit => "true",
      useresult => "install_return";

      "REDIS CONFIGURE $(runenv)"
      inherit => "true",
      usebundle => conf($(runenv), $(metadata), "$(install_return[package_status])",$(pidfile), $(port), $(address), $(timeout),
                        $(dbfilename), $(datadir), $(logfile), $(glueoutputbuf), $(shareobjectspoolsize), $(masterserver), 
                        $(masterport), "@(server.saves)"),
      useresult => "config_return";

      "REDIS PROCESS $(runenv)"
      inherit => "true",
      usebundle => proc("$(config_return[service_mode])");

    verbose::
      "metadata" usebundle => default:report_metadata($(this.bundle), $(metadata)),
      inherit => "true";
}

bundle agent install
{
  packages:
    not_test.(ubuntu|debian)::
      "redis-server"
      package_policy => "add",
      classes => default:if_ok("redis_installed"),
      package_method => default:apt;

  reports:
    verbose.redis_installed::
      "$(this.bundle): Installed Redis successfully.";
    verbose.not_test.!redis_installed::
      "$(this.bundle): Could not install Redis successfully.";

    redis_installed::
      "1" bundle_return_value_index => "package_status";
    not_test.!redis_installed::
      "0" bundle_return_value_index => "package_status";
    test::
      "$(this.bundle): Overriding bundle return status to success (1) in test mode";
      "1" bundle_return_value_index => "package_status";
}

bundle agent conf(runenv, metadata, pkg_status, pidfile, port, address, timeout, dbfilename, datadir, logfile, glueoutputbuf, shareobjectspoolsize, masterserver, masterport, saves)
{
  classes:
      "redis_installed" expression => strcmp("1", $(pkg_status));

  files:
    redis_installed.(ubuntu|debian)::
      "$(default:eu.path_prefix)/etc/redis/redis.conf"
      create => "true",
      edit_defaults => default:empty,
      perms => default:mog("644","redis","redis"),
      classes => default:if_repaired("config_repaired"),
      edit_line => edit_config(
                                $(pidfile),
                                $(port),
                                $(address),
                                $(timeout),
                                $(dbfilename),
                                $(datadir),
                                $(logfile),
                                $(glueoutputbuf),
                                $(shareobjectspoolsize),
                                $(masterserver),
                                $(masterport),
                                "@(conf.saves)"
      );
      # commands:

  reports:
    config_repaired::
      "restart" bundle_return_value_index => "service_mode";
    !config_repaired::
      "start" bundle_return_value_index => "service_mode";
}

bundle agent proc(service_mode) {
  classes:
      "conf_repaired" expression => strcmp("restart",$(service_mode));

  processes:
    !conf_repaired::
      "redis"
      restart_class => "proc_start";

  commands:
    conf_repaired::
      "$(default:eu.exec_prefix)/etc/init.d/redis-server restart";
    proc_start::
      "$(default:eu.exec_prefix)/etc/init.d/redis-server start";
}

bundle edit_line edit_config(pidfile, port, address, timeout, dbfilename, datadir, logfile, glueoutputbuf, shareobjectspoolsize, masterserver, masterport, saves)
{
  insert_lines:
      "###
# Generated by CFEngine for $(sys.fqhost)
###

# By default Redis does not run as a daemon. Use 'yes' if you need it.
# Note that Redis will write a pid file in /var/run/redis.pid when daemonized.
#
# Set to no because we're using runit
daemonize yes

# When run as a daemon, Redis write a pid file in /var/run/redis.pid by default.
# You can specify a custom pid file location here.
pidfile $(pidfile)

# Accept connections on the specified port, default is 6379
port $(port)

# If you want you can bind a single interface, if the bind option is not
# specified all the interfaces will listen for connections.
#
bind $(address)

# Close the connection after a client is idle for N seconds (0 to disable)
timeout $(timeout)

# The filename where to dump the DB
dbfilename $(dbfilename)

# For default save/load DB in/from the working directory
# Note that you must specify a directory not a file name.
dir $(datadir)

# Set server verbosity to 'debug'
# it can be one of:
# debug (a lot of information, useful for development/testing)
# notice (moderately verbose, what you want in production probably)
# warning (only very important / critical messages are logged)
loglevel notice

# Specify the log file name. Also 'stdout' can be used to force
# the demon to log on the standard output. Note that if you use standard
# output for logging but daemonize, logs will be sent to /dev/null
logfile $(logfile)

# Set the number of databases. The default database is DB 0, you can select
# a different one on a per-connection basis using SELECT <dbid> where
# dbid is a number between 0 and 'databases'-1
databases 16


################################## SECURITY ###################################

# Require clients to issue AUTH <PASSWORD> before processing any other
# commands.  This might be useful in environments in which you do not trust
# others with access to the host running redis-server.
#
# This should stay commented out for backward compatibility and because most
# people do not need auth (e.g. they run their own servers).

# requirepass foobared

################################### LIMITS ####################################

# Set the max number of connected clients at the same time. By default there
# is no limit, and it's up to the number of file descriptors the Redis process
# is able to open. The special value '0' means no limts.
# Once the limit is reached Redis will close all the new connections sending
# an error 'max number of clients reached'.

# maxclients 128

# Don't use more memory than the specified amount of bytes.
# When the memory limit is reached Redis will try to remove keys with an
# EXPIRE set. It will try to start freeing keys that are going to expire
# in little time and preserve keys with a longer time to live.
# Redis will also try to remove objects from free lists if possible.
#
# If all this fails, Redis will start to reply with errors to commands
# that will use more memory, like SET, LPUSH, and so on, and will continue
# to reply to most read-only commands like GET.
#
# WARNING: maxmemory can be a good idea mainly if you want to use Redis as a
# 'state' server or cache, not as a real DB. When Redis is used as a real
# database the memory usage will grow over the weeks, it will be obvious if
# it is going to use too much memory in the long run, and you'll have the time
# to upgrade. With maxmemory after the limit is reached you'll start to get
# errors for write operations, and this may even lead to DB inconsistency.

# maxmemory <bytes>

############################### ADVANCED CONFIG ###############################

# Glue small output buffers together in order to send small replies in a
# single TCP packet. Uses a bit more CPU but most of the times it is a win
# in terms of number of queries per second. Use 'yes' if unsure.
glueoutputbuf $(glueoutputbuf)

# Save the DB on disk:
#
#   save <seconds> <changes>
#
#   Will save the DB if both the given number of seconds and the given
#   number of write operations against the DB occurred.
#";

      "save $(saves)";

      "# Use object sharing. Can save a lot of memory if you have many common
# string in your dataset, but performs lookups against the share objects
# pool so it uses more CPU and can be a bit slower. Usually it's a good
# idea.
#
# When object sharing is enabled (shareobjects yes) you can use
# shareobjectspoolsize to control the size of the pool used in order to try
# object sharing. A bigger pool size will lead to better sharing capabilities.
# In general you want this value to be at least the double of the number of
# very common strings you have in your dataset.
#
# WARNING: object sharing is experimental, don't enable this feature
# in production before of Redis 1.0-stable. Still please try this feature in
# your development environment so that we can test it better.
shareobjectspoolsize $(shareobjectspoolsize)"
      ifvarclass => not(strcmp($(shareobjectspoolsize), "disabled"));

      "################################# REPLICATION #################################
# Master-Slave replication. Use slaveof to make a Redis instance a copy of
# another Redis server. Note that the configuration is local to the slave
# so for example it is possible to configure the slave to save the DB with a
# different interval, or to listen to another port, and so on.

slaveof $(masterserver) $(masterport)"
      ifvarclass => not(or(strcmp($(masterserver),"0.0.0.0"),
                           strcmp($(masterport),"0")));

}
