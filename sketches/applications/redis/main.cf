body file control
{
  namespace => "cfdc_applications_redis";
}

bundle agent applications_redis(runenv,metadata,pidfile,port,address,timeout,dbfilename,datadir,logfile,glueoutputbuf,shareobjectspoolsize,masterserver,masterport,saves)
{
	methods:
		"REDIS INSTALL $(runenv)" 
			usebundle => applications_redis_install,
			useresult => "install_return";
		"REDIS CONFIGURE $(runenv)"
			usebundle => applications_redis_conf("$(runenv)","$(metadata)","$(install_return[package_status])","$(pidfile)","$(port)","$(address)","$(timeout)",
                                           "$(dbfilename)","$(datadir)","$(logfile)","$(glueoutputbuf)","$(shareobjectspoolsize)","$(masterserver)",
                                           "$(masterport)","@(applications_redis.saves)"),
			useresult => "config_return";
		"REDIS PROCESS $(runenv)"
			usebundle => applications_redis_proc("$(config_return[service_mode])");
}

bundle agent applications_redis_install
{
	packages:
		ubuntu|debian::
			"redis-server"
				package_policy => "add",
				classes => default:if_ok("applications_redis_installed"),
				package_method => default:apt;

	reports:
		applications_redis_installed::
			"installed" bundle_return_value_index => "package_status";
		!applications_redis_installed::
			"not_installed" bundle_return_value_index => "package_status";
}

bundle agent applications_redis_conf(runenv,metadata,pkg_status,pidfile,port,address,timeout,dbfilename,datadir,logfile,glueoutputbuf,shareobjectspoolsize,masterserver,masterport,saves)
{
	
	classes:
		"redis_installed" expression => strcmp("installed", "$(pkg_status)");

	files:
		redis_installed.(ubuntu|debian)::
			"/etc/redis/redis.conf"
				create => "true",
				edit_defaults => default:empty,
				perms => default:mog("644","redis","redis"),
				classes => default:if_repaired("applications_redis_config_repaired"),
				edit_line => applications_redis_edit_config(
			                                       "$(pidfile)",
																						 "$(port)",
																						 "$(address)",
																						 "$(timeout)",
																						 "$(dbfilename)",
																						 "$(datadir)",
																						 "$(logfile)",
																						 "$(glueoutputbuf)",
																						 "$(shareobjectspoolsize)",
																						 "$(masterserver)",
																						 "$(masterport)",
																						 "@(applications_redis_conf.saves)"
																						);
#	commands:

	reports:
		applications_redis_config_repaired::
			"restart" bundle_return_value_index => "service_mode";
		!applications_redis_config_repaired::
			"start" bundle_return_value_index => "service_mode";
}	

bundle agent applications_redis_proc(service_mode) {
	classes:
		"applications_redis_conf_repaired" expression => strcmp("restart","$(service_mode)");
	
	processes:
		!applications_redis_conf_repaired::
			"redis"
				restart_class => "applications_redis_proc_start";

	commands:
		applications_redis_conf_repaired::
			"/etc/init.d/redis-server restart";
		applications_redis_proc_start::
			"/etc/init.d/redis-server start";
}

bundle edit_line applications_redis_edit_config(pidfile,port,address,timeout,dbfilename,datadir,logfile,glueoutputbuf,shareobjectspoolsize,masterserver,masterport,saves) {
	insert_lines:
"###
# Generated by CFEngine for $(sys.fqhost)
###
 
# By default Redis does not run as a daemon. Use 'yes' if you need it.
# Note that Redis will write a pid file in /var/run/redis.pid when daemonized.
#
# Set to no because we're using runit
daemonize yes
 
# When run as a daemon, Redis write a pid file in /var/run/redis.pid by default.
# You can specify a custom pid file location here.
pidfile $(pidfile)
 
# Accept connections on the specified port, default is 6379
port $(port)
 
# If you want you can bind a single interface, if the bind option is not
# specified all the interfaces will listen for connections.
#
bind $(address)
 
# Close the connection after a client is idle for N seconds (0 to disable)
timeout $(timeout)
 
# The filename where to dump the DB
dbfilename $(dbfilename)
 
# For default save/load DB in/from the working directory
# Note that you must specify a directory not a file name.
dir $(datadir)
 
# Set server verbosity to 'debug'
# it can be one of:
# debug (a lot of information, useful for development/testing)
# notice (moderately verbose, what you want in production probably)
# warning (only very important / critical messages are logged)
loglevel notice
 
# Specify the log file name. Also 'stdout' can be used to force
# the demon to log on the standard output. Note that if you use standard
# output for logging but daemonize, logs will be sent to /dev/null
logfile $(logfile)
 
# Set the number of databases. The default database is DB 0, you can select
# a different one on a per-connection basis using SELECT <dbid> where
# dbid is a number between 0 and 'databases'-1
databases 16
 
 
################################## SECURITY ###################################
 
# Require clients to issue AUTH <PASSWORD> before processing any other
# commands.  This might be useful in environments in which you do not trust
# others with access to the host running redis-server.
#
# This should stay commented out for backward compatibility and because most
# people do not need auth (e.g. they run their own servers).
 
# requirepass foobared
 
################################### LIMITS ####################################
 
# Set the max number of connected clients at the same time. By default there
# is no limit, and it's up to the number of file descriptors the Redis process
# is able to open. The special value '0' means no limts.
# Once the limit is reached Redis will close all the new connections sending
# an error 'max number of clients reached'.
 
# maxclients 128
 
# Don't use more memory than the specified amount of bytes.
# When the memory limit is reached Redis will try to remove keys with an
# EXPIRE set. It will try to start freeing keys that are going to expire
# in little time and preserve keys with a longer time to live.
# Redis will also try to remove objects from free lists if possible.
#
# If all this fails, Redis will start to reply with errors to commands
# that will use more memory, like SET, LPUSH, and so on, and will continue
# to reply to most read-only commands like GET.
#
# WARNING: maxmemory can be a good idea mainly if you want to use Redis as a
# 'state' server or cache, not as a real DB. When Redis is used as a real
# database the memory usage will grow over the weeks, it will be obvious if
# it is going to use too much memory in the long run, and you'll have the time
# to upgrade. With maxmemory after the limit is reached you'll start to get
# errors for write operations, and this may even lead to DB inconsistency.
 
# maxmemory <bytes>
 
############################### ADVANCED CONFIG ###############################
 
# Glue small output buffers together in order to send small replies in a
# single TCP packet. Uses a bit more CPU but most of the times it is a win
# in terms of number of queries per second. Use 'yes' if unsure.
glueoutputbuf $(glueoutputbuf)
 
# Save the DB on disk:
#
#   save <seconds> <changes>
#
#   Will save the DB if both the given number of seconds and the given
#   number of write operations against the DB occurred.
#";

"save $(saves)";

"# Use object sharing. Can save a lot of memory if you have many common
# string in your dataset, but performs lookups against the share objects
# pool so it uses more CPU and can be a bit slower. Usually it's a good
# idea.
#
# When object sharing is enabled (shareobjects yes) you can use
# shareobjectspoolsize to control the size of the pool used in order to try
# object sharing. A bigger pool size will lead to better sharing capabilities.
# In general you want this value to be at least the double of the number of
# very common strings you have in your dataset.
#
# WARNING: object sharing is experimental, don't enable this feature
# in production before of Redis 1.0-stable. Still please try this feature in
# your development environment so that we can test it better.
shareobjectspoolsize $(shareobjectspoolsize)"
	ifvarclass => not(strcmp("$(shareobjectspoolsize)", "disabled"));

"################################# REPLICATION #################################
# Master-Slave replication. Use slaveof to make a Redis instance a copy of
# another Redis server. Note that the configuration is local to the slave
# so for example it is possible to configure the slave to save the DB with a
# different interval, or to listen to another port, and so on.
 
slaveof $(masterserver) $(masterport)"
	ifvarclass => not(or(strcmp("$(masterserver)","0.0.0.0"),strcmp("$(masterport)","0")));

}

